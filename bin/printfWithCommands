#!/bin/bash

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" 'FORMAT ( -a|--argument ARGUMENT | -c|--command COMMANDLINE ) [...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Format and print ARGUMENTS or the outputs of COMMANDS under control of the
FORMAT.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --argument|-a ARG	An argument to be used for the corresponding placeholder
			in FORMAT.
    --command|-c CMD	A command line to be executed. If the command succeeds,
			the output will be used for the corresponding
			placeholder in FORMAT. If it fails, the whole printing
			will be aborted and the failing exit status returned.

Unlike "printf FORMAT \$(COMMAND)" this does not ignore errors, but
instead fails if one of the COMMANDS fails.
HELPTEXT
}
case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
esac

format="$1"; shift

# Do a first parse to verify the overall syntax, then repeat with execution.
typeset -a savedArgs=("$@")
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--command|-c)	shift; shift;;
	--argument|-a)	shift; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -gt 0 ]; then
    printUsage "$0" >&2
    exit 2
fi
set -- "${savedArgs[@]}"

typeset -a resolvedArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--command|-c)	shift; resolvedArgs+=("$(eval "$1")") || exit $?; shift;;
	--argument|-a)	shift; resolvedArgs+=("$1"); shift;;
    esac
done

printf "$format" "${resolvedArgs[@]}"
