#!/bin/bash
set -o noglob
shopt -qs extglob

: ${COMMANDONSELECTED_ENTRIES_MARKER:='{}'}
entriesMarker="$COMMANDONSELECTED_ENTRIES_MARKER"; unset COMMANDONSELECTED_ENTRIES_MARKER
: ${COMMANDONSELECTED_POST_FILTER_MARKER:='{}'}
postFilterMarker="$COMMANDONSELECTED_POST_FILTER_MARKER"; unset COMMANDONSELECTED_POST_FILTER_MARKER

fuzzyTrigger=; callable fzf && fuzzyTrigger=z

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" "[--accept-single] [--single-only] [-g|--generator GENERATOR] [-f|--filter ''|FILTER] [--post-filter FILTER] [-c|--command \"COMMANDLINE\" [-c ...]] [--] [SELECTION ...] [--] [ENTRIES ...] [-?|-h|--help]"
    printf 'Usage: GENERATOR | %q %s\n' "$(basename "$1")" '--stdin [-c ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Read entries (one per line) from GENERATOR / standard input / passed ENTRIES,
present as a numbered list and read selections (unless SELECTIONs have already
been passed).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT

Passed ENTRIES are then passed to GENERATOR for further filtering unless FILTER
is given, in which case it is passed to it, or taken as-is if FILTER is empty.
If SELECTIONs are passed, the resulting entries are selected from them.
Selection works by numbers, starting with 1 for the first entry; you can also
use enumerations (1 3 4) and ranges (2-5 or 3-; instead of relying on brace
expansion {2..5}); negative numbers select from the end, so -1 is the last one.
/N selects all but entry N; // starts interactive subtraction from all passed
entries.${fuzzyTrigger:+
$fuzzyTrigger starts selection via fuzzy matching (using fzf).}

Without SELECTIONs, show a (numbered) list of them to the user (or accept a
single available ENTRY if --accept-single is given), and ask for selections (or
allow further filtering of the list, or invert the selection via //). With
--single-only, the querying stops when at least one entry has been selected (and
any additional ones are ignored and a warning is printed).
The selected entries are then passed to the COMMANDLINE (either appended or
replacing any $entriesMarker marker) [or printed].

    --post-filter FILTER
		    Pass the selected entries as individual arguments to FILTER
		    (either appended or replacing $postFilterMarker), which should return
		    each on a separate line, before these are passed to
		    COMMANDLINE [or printed].

EXIT STATUS
Exits with 2 if a bad selection was made, 124 if there are no entries available,
125 if no entries were selected.
HELPTEXT
}

isAcceptSingle=
isMultiSelect=t
isStdin=
typeset -a targetCommands=()
generator=
unset filter
postFilter=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	    shift; printLongUsage "$0"; exit 0;;
	--accept-single)    shift; isAcceptSingle=t;;
	--single-only)	    shift; isMultiSelect=;;
	--stdin)	    shift; isStdin=t;;
	--generator|-g)	    shift; generator="$1"; shift;;
	--filter|-f)	    shift; filter="$1"; shift;;
	--post-filter)	    shift; postFilter="$1"; shift;;
	--command|-c)	    shift; targetCommands+=(${targetCommands:+;} "$1"); shift;;
	--)		    shift; break;;
	-[^0-9]*)	    { echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		    break;
    esac
done

isFirstSelection=t
isFuzzySelection=
isSubtract=
typeset -a selected=()
while [ $# -ne 0 ]
do
    case "$1" in
	--)			shift; break;;
	//)			if [ "$isFirstSelection" ]; then shift; isSubtract=t; fi
				break
				;;
	${fuzzyTrigger:---})	if [ -n "$isFirstSelection" -a $# -eq 1 ]; then shift; isFuzzySelection=t; fi
				break
				;;
	?(/?(-)|-)+([0-9]))	selected+=("$1"); shift;;
	+([0-9])-+([0-9]))	eval "selected+=({${1/-/..}})"; shift;;
	/+([0-9])-+([0-9]))	range="${1#/}"; eval "selected+=(/{${range/-/..}})"; shift;;
	+([0-9])-)		if [ "$1" = '1-' ]; then echo >&2 "Cannot select all entries like this."; exit 2; fi
				previous=$((${1%-} - 1)); eval "selected+=(/{1..$previous})"; shift
				;;
	*)			break;;
    esac
    isFirstSelection=
done

typeset -a entries=()
if [ $# -gt 0 ]; then
    entries=("$@")
elif [ "$isStdin" ]; then
    mapfile -t entries
    { exec 0</dev/tty; } 2>/dev/null || exit $?
fi

if [ ${#entries[@]} -gt 0 -a -n "${filter+t}" ]; then
    entrySource="$filter"
else
    entrySource="$generator"
fi
if [ -n "$entrySource" ]; then
    saveIFS=$IFS
    IFS=$'\n'
    entries=($(eval "$entrySource" '"${entries[@]}"'))
    IFS=$saveIFS
fi


if [ ${#entries[@]} -eq 0 ]; then
    exit 124
elif [ ${#entries[@]} -eq 1 -a \( "$isAcceptSingle" -o ! "$isMultiSelect" \) ]; then
    typeset -a selectedEntries=("${entries[@]}")
else
    isFirst=t
    typeset -a selectedEntries=()
    invertCandidates()
    {
	typeset -a invertedEntries=()
	for entry
	do
	    contains "$entry" "${selectedEntries[@]}" || invertedEntries+=("$entry")
	done
	selectedEntries=("${invertedEntries[@]}")
    }
    typeset -a filters=()
    printCurrentFilter()
    {
	local prefix="${1:?}"; shift
	case $# in
	    0)	;;
	    1)	echo >&2 "$prefix at full list of entries; press Enter to show again.";;
	    *)	printf >&2 '%s at filter %s;\n%spress Enter to show entries again, Ctrl-D or ".." to leave this filter,\n%s"." to finish selecting.\n' \
		    "$prefix" \
		    "$(joinBy ' > ' "${@:1:$(($#-1))}")" \
		    "${prefix%%+([^	 ])}" \
		    "${prefix%%+([^	 ])}"
		;;
	esac
    }
    selectCandidates()
    {
	local entry
	select entry
	do
	    if [ "$entry" ]; then
		selectedEntries+=("$entry")
	    else
		local isBreak=
		case "$REPLY" in
		    .)  filters=();&
		    ..) isBreak=t;;
		    //) invertCandidates "$@"; isBreak=t;;
		    ${fuzzyTrigger:-.})
			selectFuzzy "$@"; isBreak=t;;
		    \?) quote='"'
			cat >&2 <<-EOF
			    Enter each number (one after the other) to select the entry.
			    You can also use ranges (2-5 or 3-); negative numbers select from the end.
			    /N selects all but entry N, * selects all entries.
			    Filter the list by entering "grep" arguments. (Double backslashes.)
EOF
			if [ ${#filters[@]} -gt 1 ]; then
			    cat >&2 <<-EOF
			    Leave the current filter by appending or entering ".." to entered numbers or
			    ranges, or by pressing Ctrl-D.
			    Finish selecting altogether by appending or entering a single ".".
EOF
			else
			    cat >&2 <<-EOF
			    Finish selecting by appending or entering a single ".", or pressing Ctrl-D.
EOF
			fi
			cat >&2 <<-EOF
			    Take the inversion (i.e. all not selected entries) by entering "//"${fuzzyTrigger:+
    Switch to fuzzy matching (using fzf) by entering ${quote}${fuzzyTrigger}${quote}}
EOF
			printCurrentFilter '    Currently' "${filters[@]}" ''
			if [ ${#selectedEntries[@]} -eq 0 ]; then
			    echo >&2 'Nothing selected yet.'
			else
			    local IFS=' '
			    printf >&2 '%d out of %d selected: %s\n' ${#selectedEntries[@]} ${#entries[@]} "$(joinBy ', ' "${selectedEntries[@]}")"
			fi
			;;
		    \**( ).)
			filters=();&
		    \**( )..)
			isBreak=t
			;&
		    \*)
			selectedEntries+=("$@")
			;;
		    +([0-9])*( ).)
			filters=();&
		    +([0-9])*( )..)
			selectedEntries+=("${@:${REPLY%%*( )+(.)}:1}")
			isBreak=t
			;;
		    +([0-9]))
			entryPlural=ies; [ $# -eq 1 ] && entryPlural=y
			filterNote=; [ $# -lt ${#entries[@]} ] && filterNote=' filtered'
			printf >&2 'Only %d%s entr%s.\n' $# "$filterNote" "$entryPlural"
			;;
		    ?(-)+([0-9])+( ?(-)+([0-9]))*( ).)
			filters=();&
		    ?(-)+([0-9])+( ?(-)+([0-9]))*( )..)
			REPLY="${REPLY%%*( )+(.)}"
			isBreak=t
			;&
		    ?(-)+([0-9])+( ?(-)+([0-9])))
			eval "selected=($REPLY)"
			selectByCounts "$@"
			;;
		    @(/?(-)|-)+([0-9])*( ).)
			filters=();&
		    @(/?(-)|-)+([0-9])*( )..)
			REPLY="${REPLY%%*( )+(.)}"
			isBreak=t
			;&
		    @(/?(-)|-)+([0-9]))
			selected=("$REPLY")
			selectByCounts "$@"
			;;
		    +([0-9])-+([0-9])*( ).)
			filters=();&
		    +([0-9])-+([0-9])*( )..)
			REPLY="${REPLY%%*( )+(.)}"
			isBreak=t
			;&
		    +([0-9])-+([0-9]))
			eval "selected=({${REPLY/-/..}})"
			selectByCounts "$@"
			;;
		    /+([0-9])-+([0-9])*( ).)
			filters=();&
		    /+([0-9])-+([0-9])*( )..)
			REPLY="${REPLY%%*( )+(.)}"
			isBreak=t
			;&
		    /+([0-9])-+([0-9]))
			range="${REPLY#/}"; eval "selected=(/{${range/-/..}})"
			selectByCounts "$@"
			;;
		    +([0-9])-*( ).)
			filters=();&
		    +([0-9])-*( )..)
			REPLY="${REPLY%%*( )+(.)}"
			isBreak=t
			;&
		    +([0-9])-)
			eval "selected=({${REPLY%-}..$#})"
			selectByCounts "$@"
			;;
		    *)  local IFS=$'\n'
			typeset -a filteredEntries=($(unset IFS; printf '%s\n' "$@" | grep $REPLY))
			if [ ${#filteredEntries[@]} -eq 0 ]; then
			    echo >&2 "No results from filtering."
			else
			    filters+=("$REPLY")
				selectCandidates "${filteredEntries[@]}"
				[ ${#filters[@]} -eq 0 ] && break
			    filters=("${filters[@]:0:$((${#filters[@]}-1))}")
			fi
			;;
		esac
		if [ "$isBreak" ]; then
		    printCurrentFilter 'Back' "${filters[@]}"
		    break
		fi
	    fi

	    [ ${#selectedEntries[@]} -eq 1 -a ! "$isMultiSelect" ] && break
	done
	[ "$isSubtract" ] && invertCandidates "$@"
	shift
    }
    selectByCounts()
    {
	local s
	for s in "${selected[@]}"
	do
	    local isSubtract=
	    local count
	    case "$s" in
		/*)	[ "$isFirst" ] && selectedEntries=("$@")
			isSubtract=t
			if [ "${s:1:1}" = '-' ]; then
			    count=$(($# - ${s:2} + 1))
			else
			    count=${s:1}
			fi
			;;
		-*)	count=$(($# - ${s:1} + 1));;
		*)	count=$s;;
	    esac
	    isFirst=

	    if [ $count -lt 1 -o $count -gt $# ]; then
		entryPlural=ies; [ $# -eq 1 ] && entryPlural=y
		printf >&2 'Only %d entr%s.\n' $# "$entryPlural"
		exit 2
	    fi

	    if [ "$isSubtract" ]; then
		let count-=1	# Array indexing is 0-based.
		unset selectedEntries[$count]
	    else
		selectedEntries+=("${@:$count:1}")
	    fi
	done
    }
    selectFuzzy()
    {
	local IFS=$'\n'
	selectedEntries+=($(printf '%s\n' "$@" | fzf ${isMultiSelect:+--multi}))
    }

    if [ ${#selected[@]} -eq 0 ]; then
	if [ "$isFuzzySelection" ]; then
	    selectFuzzy "${entries[@]}"
	else
	    selectCandidates "${entries[@]}"
	fi
    else
	selectByCounts "${entries[@]}"
    fi
fi


[ ${#selectedEntries[@]} -eq 0 ] && exit 125

if [ ! "$isMultiSelect" -a ${#selectedEntries[@]} -gt 1 ]; then
    printf >&2 'Note: %d entries selected; ignoring all but the first.\n' "${#selectedEntries[@]}"
    selectedEntries=("${selectedEntries[0]}")
fi

if [ -n "$postFilter" ]; then
    for selectedEntry in "${selectedEntries[@]}"
    do
	printf -v selectedEntry %q "$selectedEntry"
	quotedSelectedEntries="${quotedSelectedEntries}${quotedSelectedEntries:+ }${selectedEntry}"
    done

    typeset -a se=("${selectedEntries[@]}")
    interpolatedPostFilter="${postFilter//"$postFilterMarker"/$quotedSelectedEntries}"
    [ "$interpolatedPostFilter" = "$postFilter" ] || se=()

    saveIFS=$IFS
    IFS=$'\n'
    selectedEntries=($(eval "$interpolatedPostFilter" '"${se[@]}"'))
    IFS=$saveIFS
fi

typeset -a e=('"${selectedEntries[@]}"')
if [ ${#targetCommands[@]} -gt 0 ]; then
    typeset -a interpolatedCommands=("${targetCommands[@]//"$entriesMarker"/'"${selectedEntries[@]}"'}")
    [ "${interpolatedCommands[*]}" = "${targetCommands[*]}" ] || e=()
else
    typeset -a interpolatedCommands=("printf '%s\\n'")
fi

eval "${interpolatedCommands[@]}" "${e[@]}"
