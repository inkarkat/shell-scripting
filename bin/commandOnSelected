#!/bin/bash
shopt -qs extglob

fuzzyTrigger=; callable fzf && fuzzyTrigger=z

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" "[--accept-single] [-g|--generator GENERATOR] [-f|--filter ''|FILTER] [-c|--command COMMAND] [--] [ENTRIES] [--] [SELECTION ...] [-?|-h|--help]"
    printf 'Usage: GENERATOR | %q %s\n' "$(basename "$1")" '--stdin [-c ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Read entries (one per line) from GENERATOR / standard input / passed ENTRIES,
present as a numbered list and read selections (unless SELECTIONs have already
been passed).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT

Passed ENTRIES are then passed to GENERATOR for further filtering unless FILTER
is given, in which case it is passed to it, or taken as-is if FILTER is empty).
If SELECTIONs are passed, the resulting entries are selected from them.
Selection works by numbers, starting with 1 for the first entry; you can also
use ranges (2-5 or 3-; instead of relying on brace expansion {2..5}); negative
numbers select from the end, so -1 is the last one. /N selects all but entry N;
// starts interactive subtraction from all passed entries.${fuzzyTrigger:+
$fuzzyTrigger starts selection via fuzzy matching (using fzf).}

Without SELECTIONs, show a (numbered) list of them to the user (or accept a
single available ENTRY if --accept-single is given), and ask for selections (or
allow further filtering of the list, or invert the selection via //).
The selected entries are then passed to the COMMAND [or printed].

EXIT STATUS
Exits with 2 if a bad selection was made, 124 if there are no entries available,
125 if no entries were selected.
HELPTEXT
}

isAcceptSingle=
isStdin=
targetCommand=
generator=
unset filter
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	    shift; printLongUsage "$0"; exit 0;;
	--accept-single)    shift; isAcceptSingle=t;;
	--stdin)	    shift; isStdin=t;;
	--generator|-g)	    shift; generator="$1"; shift;;
	--filter|-f)	    shift; filter="$1"; shift;;
	--command|-c)	    shift; targetCommand="$1"; shift;;
	--)		    shift; break;;
	-[^0-9]*)	    { echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		    break;
    esac
done

isFirstSelection=t
isFuzzySelection=
isSubtract=
typeset -a selected=()
while [ $# -ne 0 ]
do
    case "$1" in
	--)			shift; break;;
	//)			if [ "$isFirstSelection" ]; then shift; isSubtract=t; fi
				break
				;;
	${fuzzyTrigger:---})	if [ -n "$isFirstSelection" -a $# -eq 1 ]; then shift; isFuzzySelection=t; fi
				break
				;;
	?([/-])+([0-9]))	selected+=("$1"); shift;;
	+([0-9])-+([0-9]))	eval "selected+=({${1/-/..}})"; shift;;
	/+([0-9])-+([0-9]))	range="${1#/}"; eval "selected+=(/{${range/-/..}})"; shift;;
	+([0-9])-)		if [ "$1" = '1-' ]; then echo >&2 "Cannot select all entries like this."; exit 2; fi
				previous=$((${1%-} - 1)); eval "selected+=(/{1..$previous})"; shift
				;;
	*)			break;;
    esac
    isFirstSelection=
done

typeset -a entries=()
if [ $# -gt 0 ]; then
    entries=("$@")
elif [ "$isStdin" ]; then
    mapfile -t entries
    { exec 0</dev/tty; } 2>/dev/null || exit $?
fi

if [ ${#entries[@]} -gt 0 -a -n "${filter+t}" ]; then
    entrySource="$filter"
else
    entrySource="$generator"
fi
if [ "$entrySource" ]; then
    saveIFS=$IFS
    IFS=$'\n'
    entries=($(eval "$entrySource" '"${entries[@]}"'))
    IFS=$saveIFS
fi


if [ ${#entries[@]} -eq 0 ]; then
    exit 124
elif [ ${#entries[@]} -eq 1 -a -n "$isAcceptSingle" ]; then
    typeset -a selectedEntries=("${entries[@]}")
else
    isFirst=t
    typeset -a selectedEntries=()
    invertCandidates()
    {
	typeset -a invertedEntries=()
	for entry
	do
	    contains "$entry" "${selectedEntries[@]}" || invertedEntries+=("$entry")
	done
	selectedEntries+=("${invertedEntries[@]}")
    }
    selectCandidates()
    {
	local entry
	select entry
	do
	    if [ "$entry" ]; then
		selectedEntries+=("$entry")
	    else case "$REPLY" in
		.)  break;;
		//) invertCandidates "$@"; break;;
		${fuzzyTrigger:-.})
		    selectFuzzy "$@"; break;;
		\?) quote='"'; cat >&2 <<-EOF
		    Enter each number (one after the other) to select the entry.
		    You can also use ranges (2-5 or 3-); negative numbers select from the end.
		    /N selects all but entry N.
		    Filter the list by entering "grep" arguments. (Double backslashes.)
		    Conclude by pressing Ctrl-D or entering "."
		    Take the inversion (i.e. all not selected entries) by entering "//"${fuzzyTrigger:+
    Switch to fuzzy matching (using fzf) by entering ${quote}${fuzzyTrigger}${quote}}
EOF
		    if [ ${#selectedEntries[@]} -eq 0 ]; then
			echo >&2 'Nothing selected yet.'
		    else
			local IFS=' '
			printf >&2 '%d out of %d selected: %s\n' ${#selectedEntries[@]} ${#entries[@]} "${selectedEntries[*]}"
		    fi
		    ;;
		+([0-9]))
		    entryPlural=ies; [ $# -eq 1 ] && entryPlural=y
		    filterNote=; [ $# -lt ${#entries[@]} ] && filterNote=' filtered'
		    printf >&2 'Only %d%s entr%s.\n' $# "$filterNote" "$entryPlural"
		    ;;
		[/-]+([0-9]))
		    selected=("$REPLY")
		    selectByCounts "$@"
		    ;;
		+([0-9])-+([0-9]))
		    eval "selected=({${REPLY/-/..}})"
		    selectByCounts "$@"
		    ;;
		/+([0-9])-+([0-9]))
		    range="${REPLY#/}"; eval "selected=(/{${range/-/..}})"
		    selectByCounts "$@"
		    ;;
		+([0-9])-)
		    eval "selected=({${REPLY%-}..$#})"
		    selectByCounts "$@"
		    ;;
		*)  local IFS=$'\n'
		    typeset -a filteredEntries=($(printf '%s\n' "$@" | grep $REPLY))
		    if [ ${#filteredEntries[@]} -eq 0 ]; then
			echo >&2 "No results from filtering."
		    else
			selectCandidates "${filteredEntries[@]}"
			break
		    fi
		    ;;
	    esac; fi
	done
	[ "$isSubtract" ] && invertCandidates "$@"
    }
    selectByCounts()
    {
	local s
	for s in "${selected[@]}"
	do
	    local isSubtract=
	    local count
	    case "$s" in
		/*)	[ "$isFirst" ] && selectedEntries=("$@")
			isSubtract=t
			if [ "${s:1:1}" = '-' ]; then
			    count=$(($# - ${s:2} + 1))
			else
			    count=${s:1}
			fi
			;;
		-*)	count=$(($# - ${s:1} + 1));;
		*)	count=$s;;
	    esac
	    isFirst=

	    if [ $count -lt 1 -o $count -gt $# ]; then
		entryPlural=ies; [ $# -eq 1 ] && entryPlural=y
		printf >&2 'Only %d entr%s.\n' $# "$entryPlural"
		exit 2
	    fi

	    if [ "$isSubtract" ]; then
		let count-=1	# Array indexing is 0-based.
		unset selectedEntries[$count]
	    else
		selectedEntries+=(${@:$count:1})
	    fi
	done
    }
    selectFuzzy()
    {
	local IFS=$'\n'
	selectedEntries+=($(printf '%s\n' "$@" | fzf --multi))
    }

    if [ ${#selected[@]} -eq 0 ]; then
	if [ "$isFuzzySelection" ]; then
	    selectFuzzy "${entries[@]}"
	else
	    selectCandidates "${entries[@]}"
	fi
    else
	selectByCounts "${entries[@]}"
    fi
fi


[ ${#selectedEntries[@]} -eq 0 ] && exit 125

[ "$targetCommand" ] || targetCommand="printf '%s\n'"
eval "$targetCommand" '"${selectedEntries[@]}"'
